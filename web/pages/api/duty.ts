/**
 * @fileoverview
 * This file contains the code for generating a duty roster for a given set of people.
 * The roster is generated by randomly assigning people to a given number of shifts.
 * It uses the Round-robin algorithm algorithm to generate the roster.
 */

import type { NextApiRequest, NextApiResponse } from "next";
import {
  startOfMonth,
  endOfMonth,
  getMonth,
  eachDayOfInterval,
  isWeekend,
  // format,
} from "date-fns";
import { utcToZonedTime } from "date-fns-tz";

export const MONTH_NAMES = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December",
] as const;

export type MonthName = typeof MONTH_NAMES[number];

interface Personnel {
  id: number;
  name: string;
  weekdaysPTS: number;
  weekendsPTS: number;
  extras: number;
  blockoutDates: Date[];
}

const month: MonthName = "March";
const year: number = 2023;
const timeZone = "Asia/Singapore";

/**
 *
 * The method returns an integer from 0 (January) to 11 (December).
 * @param month
 * @returns integer representing the month number (0-11)
 */
function getMonthCount(month: MonthName) {
  return getMonth(new Date(`${month} 1`));
}

/**
 * The method shuffles an array
 * @param array
 * @returns a shuffled array
 */
export function shuffleArray<T>(array: T[]): T[] {
  const arrayCopy = [...array];
  for (let i = arrayCopy.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arrayCopy[i], arrayCopy[j]] = [arrayCopy[j], arrayCopy[i]];
  }
  return arrayCopy;
}

const monthCount = getMonthCount(month);
const date = new Date(year, monthCount);
const zonedDate = utcToZonedTime(date, timeZone);

// get the starting date of the month
const startDate = startOfMonth(zonedDate);
// create an array of dates for the month
const monthDates = eachDayOfInterval({
  start: startDate,
  end: endOfMonth(startDate),
});

// List of people to be assigned duties
const personnel = [
  {
    id: 1,
    name: "John",
    weekdaysPTS: 0,
    weekendsPTS: 0,
    extras: 0,
    blockoutDates: [],
  },
  {
    id: 2,
    name: "Jane",
    weekdaysPTS: 0,
    weekendsPTS: 0,
    extras: 0,
    blockoutDates: [],
  },
  {
    id: 3,
    name: "Joe",
    weekdaysPTS: 0,
    weekendsPTS: 0,
    extras: 0,
    blockoutDates: [],
  },
  {
    id: 4,
    name: "Jill",
    weekdaysPTS: 0,
    weekendsPTS: 0,
    extras: 0,
    blockoutDates: [],
  },
  {
    id: 5,
    name: "Jack",
    weekdaysPTS: 0,
    weekendsPTS: 0,
    extras: 0,
    blockoutDates: [],
  },
  {
    id: 6,
    name: "Jenny",
    weekdaysPTS: 0,
    weekendsPTS: 0,
    extras: 0,
    blockoutDates: [],
  },
  {
    id: 7,
    name: "Jen",
    weekdaysPTS: 0,
    weekendsPTS: 0,
    extras: 0,
    blockoutDates: [],
  },
  {
    id: 8,
    name: "Jenny",
    weekdaysPTS: 0,
    weekendsPTS: 0,
    extras: 0,
    blockoutDates: [],
  },
];

/**
 *
 * @param array an array of objects
 * @param key string or number
 * @returns a sorted array of objects
 * @example sortByKey(personnel, 'id')
 */
function sortByKey(array: any[], key: string | number) {
  return array.sort(function (a, b) {
    var x = a[key];
    var y = b[key];
    return x < y ? -1 : x > y ? 1 : 0;
  });
}

// This function creates the duty roster
function createDutyRoster(personnel: Personnel[], monthDates: Date[]) {
  const roster: { [date: string]: Personnel } = {};

  const weekendAllocation = calculateWeekendAllocation(personnel, monthDates);
  const weekdayAllocation = calculateWeekdayAllocation(personnel, monthDates);

  allocateExtraDuty(personnel, monthDates);

  let startIndex = 0;

  monthDates.forEach((date) => {
    if (isWeekend(date)) {
      const weekendPersonnel = personnel.slice(
        startIndex,
        startIndex + weekendAllocation
      );
      startIndex += weekendAllocation;
      weekendPersonnel.forEach((person) => {
        roster[date.toDateString()] = person;
        person.weekendsPTS += 1;
      });
    } else {
      const weekdayPersonnel = personnel.slice(
        startIndex,
        startIndex + weekdayAllocation
      );
      startIndex += weekdayAllocation;
      weekdayPersonnel.forEach((person) => {
        roster[date.toDateString()] = person;
        person.weekdaysPTS += 1;
      });
    }
  });

  return roster;
}

const dutyRoster = createDutyRoster(personnel, monthDates);

// This function allocates the extra duties
function allocateExtraDuty(personnel: Personnel[], monthDates: Date[]) {
  let personnelShuffled = shuffleArray(personnel);
  personnelShuffled = sortByKey(personnelShuffled, "extras").reverse();
}

function calculateWeekendAllocation(
  personnel: Personnel[],
  monthDates: Date[]
) {
  const totalWeekendDays = monthDates.filter((date) => isWeekend(date)).length;
  const totalPersonnel = personnel.length;

  const weekendAllocation = Math.floor(totalWeekendDays / totalPersonnel);

  return weekendAllocation;
}

function calculateWeekdayAllocation(
  personnel: Personnel[],
  monthDates: Date[]
) {
  // total_wd = total_days - total_we - len(extradates) + non_allocated_extras
  const totalWeekdayDays = monthDates.filter((date) => !isWeekend(date)).length;
  const totalPersonnel = personnel.length;

  const weekdayAllocation = Math.floor(totalWeekdayDays / totalPersonnel);

  return weekdayAllocation;
}

console.log(dutyRoster);

export default async (_req: NextApiRequest, res: NextApiResponse) => {
  res.send({
    message: monthDates,
  });
};
